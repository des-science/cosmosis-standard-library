"""
The likelihood module for the DES Y5 SN simulated dataset
author: Sujeong Lee 
"""

from cosmosis.gaussian_likelihood import GaussianLikelihood
from cosmosis.datablock import names
import os
import numpy as np


# Default is to use DES only SN. To use DES+LOWZ SN, set the data_file 
# and covmat_file parameters in the ini file 
# default sim datavector and cov are generated by Ryan Camilleri 
default_data_file = os.path.join(os.path.split(__file__)[0], "DESONLY/hubble_diagram.txt")
default_covmat_file = os.path.join(os.path.split(__file__)[0], "DESONLY/covsys_000.txt")
# M_fid is absolute magnitude for data
M_fid = -19.35 
# Both data and theory are the distance modulus. 
# To marginalize the absolute magnitude M, I subtracted M_fid (fixed value) from data and 
# also subtract M (varying params) from theory. 

class DESY5SNLikelihood(GaussianLikelihood):
    x_section = names.distances
    x_name = "z"
    y_section = names.distances
    y_name = "mu"
    like_name = "desy5sn"


    def build_data(self):
        """
        Run once at the start to load in the data vectors.

        Returns x, y where x is the independent variable (redshift in this case)
        and y is the Gaussian-distribured measured variable (magnitude in this case).

        """
        filename = self.options.get_string("data_file", default=default_data_file)
        print("Loading DES Y5 SN data from {}".format(filename))

        # The only columns that we actually need here are the redshift,
        # distance modulus and distance modulus error
        # DES Y5 SN data provides distance modulus, so we need to convert it to the apparent magnitude first 
        data = np.genfromtxt(filename).T[1:,:][:,1:]
        z = data[2]
        # distance modulus
        mu_obs = data[4]
        # magnitude obtained by subtracting the absolute magnitude (DES uses) from the distance modulus
        m_obs = mu_obs + M_fid

        # We will need mag_obs_err later, when building the covariance,
        # so save it for now.
        # This also needs to be corrected? 
        # No constant substraction doesn't affect error. 
        self.mag_obs_err = data[5]

        # Return this to the parent class, which will use it
        # when working out the likelihood
        print("Found {} DES SN 5 supernovae (or bins if you used the binned data file)".format(len(z)))
        return z, m_obs

    def build_covariance(self):
        """Run once at the start to build the covariance matrix for the data"""
        filename = self.options.get_string("covmat_file", default=default_covmat_file)
        print("Loading DESY5 SN covariance from {}".format(filename))
        # The file format for the covariance has the first line as an integer
        # indicating the number of covariance elements, and the the subsequent
        # lines being the elements.
        # This data file is just the systematic component of the covariance - 
        # we also need to add in the statistical error on the magnitudes
        # that we loaded earlier
        f = open(filename)
        line = f.readline()
        n = int(line)
        C = np.zeros((n,n))
        for i in range(n):
            for j in range(n):
                C[i,j] = float(f.readline())

        # Now add in the statistical error to the diagonal
        for i in range(n):
            C[i,i] += self.mag_obs_err[i]**2
        f.close()

        # Return the covariance; the parent class knows to invert this
        # later to get the precision matrix that we need for the likelihood.
        return C

    def extract_theory_points(self, block):

        import scipy.interpolate

        # Pull out mu and z from the block.
        # self.x_section etc. are defined above - we make them variables
        # so that the user can override them in the ini file.
        # We have to cut off the first element z=0, because mu is not finite
        # there and this confuses the interpolator.
        theory_x = block[self.x_section, self.x_name][1:]
        theory_y = block[self.y_section, self.y_name][1:]

        # This makes an interpolation function
        f = scipy.interpolate.interp1d(theory_x, theory_y, kind=self.kind)

        # Actually do the interpolation at the data redshifts
        # This is the apparent magnitude
        theory = np.atleast_1d(f(self.data_x))

        # Add the absolute supernova magnitude and return
        M = block[names.supernova_params, "M"]
        #offset = block[names.supernova_params, "offset"]
        return theory + M


# This takes our class and turns it into 
setup, execute, cleanup = DESY5SNLikelihood.build_module()
